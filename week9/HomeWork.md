# Week9 课后作业
## 一. 请简述 JVM 垃圾回收原理。
#### 1. 垃圾识别算法
* 引用计数法

一个对象维护一个计数器，被引用一次计数器 +1，取消引用计数器 -1，计数器为 0 时，表示可以被回收.

此方法无法解决循环引用问题，A引用B，B又引用A，计数器永远无法变成 0.

* 根搜索法

从 GC Roots 开始搜索，找到其所有引用，然后找到这些被引用对象的所有引用，遍历完之后那些
没有与 GC Roots 相连的对象就是可以被回收的对象。

#### 2. 垃圾回收算法
* 标记-清除算法

标记垃圾对象，然后进行清除回收。

    优点：实现简单，不需要移动对象
    缺点：会产生大量的内存碎片，经过一段时间后可能没有一整块大内存空间导致 OOM

* 复制算法

将内存分成两块，只使用其中的一块，垃圾回收时，遍历当前使用的一块，把存活的对象复制到另一块
内存中，最后将当前使用的内存块全部回收。然后将两块内存的角色互换。

     优点：实现简单，运行效率高，不用考虑内存碎片问题
     缺点：只能使用一半的内存，空间利用率低

* 标记-整理算法

标记可回收的对象，将存活的对象压缩到内存的一端，然后对另一端内存进行回收。

    优点：解决了标记清除算法中内存碎片的问题
    缺点：需要进行局部对象的移动，一定程度上降低了效率
#### 3. 分代回收
JVM 将堆内存划分为年轻代、老年代和永久代。

永久代用来存放常量、类信息，Java8 之后成为元数据区，元数据区并不在虚拟机中，而是使用本地
内存。

年轻代分为 Eden区和两个Survivor（S0和S1）区，Java 创建的对象会首先分配在 Eden 区，
垃圾回收时（Minor GC）会将 Eden区中存活的对象复制到 S0 中，清空 Eden区，再次垃圾回收时，
会将 Eden 和 S0 中存活的对象复制到 S1 中，然后清空 Eden 和 S0 ，再次垃圾回收时，将
Eden 和 S1 中的对象复制到 S0 中，以此类推。每次垃圾回收之后存活对象的年龄 +1，经过几轮
Minor GC 之后将年龄大于 X 的对象直接拷贝到老年代中。

年轻代的垃圾回收使用的是复制整理算法。

老年代中的 GC 称为 Full GC，采用比较整理算法，默认使用 CMS 回收器，Java8 之后使用 G1
垃圾回收器。

#### 4. JVM 中的垃圾回收器
* Serial 串行垃圾收集器
* ParNew 并行垃圾收集器：Serial 的多线程版本
* Parallel Scavenge 并行垃圾收集器：关注吞吐量
* Serial Old收集器：老年代的 Serial 收集器
* Parallel Old收集器：老年代的Parallel Scavenge 收集器
* CMS（Concurrent Mark Sweep）：标记清除算法的垃圾收集器，关注用户线程的停顿时间，
Java7 中的默认垃圾收集器
* G1 垃圾收集器：Java8中的默认垃圾收集器
    G1 将内存划分为一个个的块，然后将对象分配到各个块中，垃圾收集时，如果一个内存块中都是
    垃圾，则直接回收该内存块。
    
    G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.

## 二. 设计一个秒杀系统，主要的挑战和问题有哪些？核心的架构方案或者思路有哪些？
#### 主要的挑战和问题
* 高并发，类似于 DDOS 攻击，并发度能够达到成千上万，甚至几十上百万
* 由于瞬时请求激增，可能导致网络带宽耗尽
* 高并发可能导致服务器瘫痪、崩溃
* 秒杀器可能导致不公平，秒杀器不断刷新页面，直到秒杀开始，抢着下单；也有可能跳过秒杀页面，
直接调用接口下单
#### 核心的架构方案和思路
* 静态化：将尽量多的内容静态化，例如商品列表页面、商品详情页面等，尽量减少数据库访问
* 使用 CDN、缓存等服务
* 并发控制，设置阀门，多级限流，只放最前面的一部分人进入秒杀系统
* 简化流程，砍掉不必要的分支流程，例如下单页面的所有数据库查询，支付流程只要在 1 天内完成即可
* 方秒杀器：随机化,url随机、订单id随机，随机token，访问上限控制
* 秒杀业务与其他业务分离，单独部署
* 服务器调优：操作系统调优、JVM调优、web容器调优、引入消息队列削峰等
* 制定应急预案：域名分离、机动服务器、下线非核心业务、快速错误、万能出错页面指向秒杀已结束页面