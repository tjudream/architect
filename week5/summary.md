# Week5 总结
## 分布式缓存架构
* 缓存采用 Hash 表存储数据，key value 形式
* 缓存的关键指标
    * 缓存命中率
        * 缓存键集合大小
        * 缓存可使用内存空间
        * 缓存对象生存时间
* 缓存分类
    * 代理缓存
    * 反向代理缓存
    * 多层反向代理缓存
    * 内容分发网络（CDN）
    * 通读缓存
        * 代理缓存，反向代理缓存，CDN 缓存都是通读缓存
        * 通读缓存给客户端返回缓存资源，并在请求未命中缓存时获取实际数据
        * 客户端连接的是通读缓存而不是生成响应的原始服务器
    * 旁路缓存
        * 对象缓存是一种旁路缓存，通常是一个 kv 存储
        * 应用查询对象缓存，询问对象是否存在，如果不存在会直接去服务器获取
    * 浏览器对象缓存
    * 本地对象缓存
    * 远程分布式对象缓存
    * Memcached 分布式对象缓存
* 分布式对象缓存的一致性 hash 算法
    
    当缓存对象越来越多是一台服务器不足以支撑时，需要使用缓存集群，此时 key 的路由就成为
    了问题。
    
    通常情况下都是对 key 计算一个 hash 值，然后对服务器台数取余，来路由 key
    
    但是当增加或减少服务器时，所有的 key 都要重新计算一遍
    
    因此引入了一致性 hash 算法
    
    初始化一个 0~2^32 的环，称为 hash 环，计算服务器节点的 hash 值并放入 hash 环中，
    然后计算 key 的 hash 值，将其路由到 >= key 的 hash 值的最近的一台服务节点上
    
    这样做存在数据的不均衡性，有可能有一台服务器存储了大量的 key，而其他服务器存储了少量
    的 key，这样在增减服务器时，如果正好下架的是 key 最多的那台服务器，或者新增的服务器
    正好是要承接大量 key 的服务器，这样会导致大量的缓存失效，压力瞬间压到后端数据库上，
    有可能瞬间压垮数据库
    
    因此又引入了虚拟节点的概念，将一台服务器拆分出若干个虚拟节点（一般是 150~200），
    分别计算虚拟节点的 hash 值并将其放入到 hash 环中，这样就能保证 key 的均衡性
    
## 消息队列与异步架构
## 负载均衡架构
## 分布式数据库